\section{Introduction}
The Wavelet Tree is a relatively new, but versatile data structure, offering solutions for many problem domains such as string processing, computational geometry, and data compression.
Storing, in its basic form, a sequence of characters from an alphabet it enables higher-order entropy compression and supports various fast queries.

In this thesis we have made a short survey of some of the various applications of a wavelet tree including uses in compression and in information retrieval.
We include descriptions of how the construction of a wavelet tree and its supported queries work in practice.

The practical implementation of a wavelet tree is susceptible, like all other algorithms, to the characteristics and imperfections of modern computer architectures that can degrade the performance by various penalties.
We describe and analyse how and why these characteristics give rise to these penalties.

We have implemented and tested the construction of a wavelet tree, comparing it to the theoretical running time.
We also implemented and tested the rank and select queries and performed a number of attempts at optimizing their running times by changing how they are calculated, changing the shape of the tree, changing what is stored and how it is stored.
We test and compare these optimizations including analysing how they perform with regards to the various penalties found in modern CPUs.

We first implemented the basic construction algorithm based on the description by Navarro~\citeA[Section 2]{Navarro:2014:WT:2592317.2592708}, then expanded the implementation in various ways to attempt to improve the query algorithms.

Our focus has been to implement something that could be useful in real world scenarios and we have used inputs we believe correspond to realistic use cases.
We have also avoided impractical optimizations such as ones that require recompilation to handle different sizes of alphabets.